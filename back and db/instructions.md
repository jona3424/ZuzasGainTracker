You've made an excellent decision to define the database and backend first. This provides a solid foundation, clear API contracts, and allows for robust testing before the frontend relies on it.

Below are the detailed prompts for an AI model to create your MySQL database schema and Java Spring Boot backend, covering all the functionalities previously discussed.

---

### **Defined JSON Structure for AI Parsing & Backend Use**

This is the target JSON structure for training plans that your backend will produce from uploaded files and store in the database. The file parsing AI should aim to output data conforming to this structure as much as possible.

```json
// Example of a Training Plan JSON structure
{
  "planId": "string-uuid", // Generated by backend when saved
  "name": "Full Body Strength Routine A",
  "description": "A 3-day per week full body routine focusing on compound movements.",
  "isActive": false, // Managed by the app, not from parsed file
  "creationDate": "2023-10-27T10:00:00Z", // Backend generated
  "lastUpdatedDate": "2023-10-27T10:00:00Z", // Backend generated
  "exercises": [
    {
      "exerciseId": "string-uuid", // Generated by backend when saved
      "name": "Barbell Squat",
      "muscleGroup": "Legs, Glutes, Core", // Categorization for filtering/stats
      "notes": "Focus on deep squats, control the eccentric phase.",
      "targetSets": 3,
      "targetRepsMin": 5, // Recommended minimum reps for a set
      "targetRepsMax": 8, // Recommended maximum reps for a set
      "recommendedRestSeconds": 120, // Rest time after completing all sets for this exercise
      "sequenceOrder": 1, // Order of exercises within a workout day
      "dayOfWeek": ["MONDAY", "WEDNESDAY", "FRIDAY"], // Optional: specific days for this exercise/plan
      "workoutDaySequence": 1, // For "Day 1", "Day 2", "Day 3" type plans
      "recommendedWeightStart": 60.0, // Optional: starting weight recommendation
      "unit": "KG" // KG or LBS
    },
    {
      "exerciseId": "string-uuid",
      "name": "Bench Press",
      "muscleGroup": "Chest, Shoulders, Triceps",
      "notes": "Keep elbows tucked slightly.",
      "targetSets": 3,
      "targetRepsMin": 6,
      "targetRepsMax": 10,
      "recommendedRestSeconds": 90,
      "sequenceOrder": 2,
      "dayOfWeek": ["MONDAY", "WEDNESDAY", "FRIDAY"],
      "workoutDaySequence": 1,
      "recommendedWeightStart": 40.0,
      "unit": "KG"
    }
    // ... more exercises
  ]
}

// Example of a Workout Session Log JSON structure (sent from frontend to backend)
{
  "planId": "string-uuid", // ID of the plan used for this session
  "startTime": "2023-10-27T15:30:00Z",
  "endTime": "2023-10-27T16:30:00Z",
  "durationSeconds": 3600,
  "exerciseLogs": [
    {
      "exerciseId": "string-uuid", // ID of the exercise from the plan
      "exerciseName": "Barbell Squat", // For redundancy and easier querying
      "setNumber": 1,
      "reps": 5,
      "weight": 100.0,
      "rpe": 8, // Rate of perceived exertion (optional, 1-10)
      "notes": "Felt heavy today, focus needed."
    },
    {
      "exerciseId": "string-uuid",
      "exerciseName": "Barbell Squat",
      "setNumber": 2,
      "reps": 5,
      "weight": 105.0,
      "rpe": 9,
      "notes": ""
    },
    {
      "exerciseId": "string-uuid",
      "exerciseName": "Bench Press",
      "setNumber": 1,
      "reps": 8,
      "weight": 70.0,
      "rpe": 7,
      "notes": ""
    }
  ]
}

// Example of a Body Metric Log JSON structure (sent from frontend to backend)
{
  "date": "2023-10-27T08:00:00Z",
  "weightKg": 75.5,
  "bodyFatPercentage": 15.2, // Optional
  "bmi": 23.5, // Optional, calculated or provided
  "measurements": { // Optional
    "bicepCm": 35.0,
    "waistCm": 80.0
  },
  "notes": "Morning measurement, post-fasting."
}
```

---

### **AI Model for File Parsing: Recommendation & Large File Strategy**

For parsing Word, PDF, and Image files into the detailed JSON structure, especially with a focus on free variants, you'll likely need a multi-stage approach rather than a single "magic" AI, especially for robust output and large files.

**Recommendation for Free/Cost-Effective AI Parsing:**

1.  **Text Extraction (Free & Open-Source Libraries - Java Focused):**
    *   **For `.docx` (Word):** Use **Apache POI**. It's a robust Java library for working with Microsoft Office formats. It can extract text, paragraphs, and even table data.
    *   **For `.pdf` (PDF):** Use **Apache PDFBox**. Another excellent Java library for text extraction, PDF manipulation, and parsing.
    *   **For Images (`.jpg`, `.png`):** Use **Tesseract OCR (via a Java wrapper like Tess4J)**. This is a powerful open-source OCR engine. You'll need to install Tesseract on your server and integrate with its API.
    *   **Pre-processing (Crucial for OCR):** Before Tesseract, use Java libraries like `ImageIO` or `OpenCV` (via JavaCV) to pre-process images (grayscale, deskew, enhance contrast) for better OCR accuracy.

2.  **Structured Data Extraction (Post-Text Extraction - Rule-based / Small LLM):**
    *   **Rule-Based Parsing (Recommended Free Approach):** After extracting raw text, implement a custom Java Spring Boot service with a set of rules and regular expressions (Regex) to identify exercise names, sets, reps, rest times, and muscle groups from the text. This is highly customizable and free but requires significant development effort and fine-tuning. It will be robust for structured training plans but can struggle with highly unstructured text.
    *   **Small, Self-Hosted LLM (More Complex Free Approach):** For greater flexibility than rule-based parsing, consider integrating with a small, locally hosted open-source LLM (e.g., a fine-tuned Mistral or Llama variant via `ollama` or similar tools). You would send text chunks to this local LLM with specific prompts to extract exercise details into JSON. This requires server resources and more setup.
    *   **Cloud-based LLM (Paid but Superior):** For the best results and minimal development effort on parsing logic, paid services like **Google's Gemini Pro API**, **OpenAI's GPT-3.5/4**, or **Anthropic's Claude** are highly recommended. They excel at understanding natural language and converting it to structured JSON. They offer free tiers for limited usage.

**Strategy for Handling Large Files & Avoiding Context Window Issues (Backend Logic):**

Your backend service will orchestrate this.

1.  **Initial File Reception:**
    *   The Spring Boot application receives the uploaded Word, PDF, or Image file.

2.  **Text Extraction & Chunking:**
    *   **Word/PDF:** Use Apache POI/PDFBox to extract text. Crucially, extract text **page by page** or **section by section (e.g., paragraph blocks)**. Each page/section becomes a "chunk."
    *   **Image:** Perform OCR (Tess4J). If the resulting text is very long, split the *extracted text* into logical blocks (e.g., by double newlines for paragraphs, or fixed character counts, ensuring not to split in the middle of an exercise description).

3.  **Iterative AI/Parsing Call (for each chunk):**
    *   For each text chunk:
        *   **If using Rule-Based Parsing:** Apply your Java Regex and parsing rules to the current chunk. It will extract any exercise data it finds within that chunk and form a partial `ExercisePlan` object or a list of such objects.
        *   **If using an LLM (local or cloud):** Send the text chunk along with a carefully engineered prompt to the LLM. The prompt should instruct the LLM to:
            *   "Analyze the following text block for training exercises. For each exercise identified, extract its name, target sets, target reps (min/max), recommended rest time, and any specific notes. Return this information as a JSON array of exercise objects, conforming to the `exercises` array within the `TrainingPlan` JSON structure provided previously. If no exercises are found, return an empty array. Do not include a plan name or description at this stage."
            *   Example LLM Prompt:
                ```
                Extract exercise details from the following text into a JSON array. Each object in the array should have 'name', 'targetSets', 'targetRepsMin', 'targetRepsMax', 'recommendedRestSeconds', 'notes', 'muscleGroup', 'sequenceOrder', 'workoutDaySequence', 'recommendedWeightStart', 'unit'. If a field is not explicitly mentioned, infer a reasonable default or leave it null. For reps, if a range like "8-12" is given, use targetRepsMin and targetRepsMax. If only "10 reps" is given, set both min and max to 10. For rest, assume seconds.
                
                Text:
                "Monday:
                1. Barbell Squats: 3 sets of 5-8 reps, 120s rest. Focus on form.
                2. Bench Press: 3 sets of 6-10 reps, 90s rest.
                3. Bent-Over Rows: 3x8-12, 60s rest."
                ```

4.  **Aggregation & Consolidation (Backend):**
    *   Your Spring Boot backend will collect all the partial JSON outputs (or `ExercisePlan` objects) from each chunk.
    *   It then aggregates these into a complete list of exercises.
    *   **Duplicate Handling:** Implement logic to identify and merge duplicate exercises if they appear across chunks (e.g., based on exercise name similarity).
    *   **Overall Plan Details:** The backend will also need to prompt the user (or use an LLM on an initial chunk) to get the overall `planName` and `description` as these are usually at the top of a document and not per-exercise.
    *   Finally, construct the full `TrainingPlan` JSON object.

This iterative approach ensures that even very large documents can be processed without exceeding the context window of an LLM, or the memory limits of rule-based parsing.

---

### **Prompts for AI Model: MySQL Database & Spring Boot Backend**

**General Instructions for the AI Model:**

You are tasked with generating the MySQL database schema and Java Spring Boot backend code for a fitness training application. Each prompt covers a specific module.

*   **MySQL:** Provide `CREATE TABLE` statements with appropriate data types, primary keys, foreign keys, and indexes. Use UUIDs for primary keys where applicable.
*   **Spring Boot:**
    *   Generate RESTful API endpoints.
    *   Implement necessary Controller, Service, Repository layers.
    *   Include DTOs (Data Transfer Objects) for request/response bodies.
    *   Use Spring Data JPA for database interactions.
    *   Implement exception handling.
    *   Ensure proper `@Transactional` annotations.
    *   Use Lombok for boilerplate code (e.g., `@Data`, `@NoArgsConstructor`, `@AllArgsConstructor`).
    *   Assume a `pom.xml` with `spring-boot-starter-web`, `spring-boot-starter-data-jpa`, `mysql-connector-java`, `spring-boot-starter-security`, `jjwt` (for JWT), `lombok`, and `spring-boot-starter-validation`.
    *   **Security:** Implement JWT-based authentication for protected endpoints.
    *   **UUIDs:** Generate UUIDs for primary keys programmatically in the backend.

---

### **Prompt 1: Core Database Schema (MySQL)**

**Objective:** Define the MySQL database tables for users, training plans, exercises, workout sessions, exercise logs, and body metrics.

**Instructions for the AI Model:**

1.  **`users` Table:**
    *   `id` (VARCHAR(36) - UUID, Primary Key)
    *   `email` (VARCHAR(255) - Unique, NOT NULL)
    *   `password_hash` (VARCHAR(255) - NOT NULL)
    *   `first_name` (VARCHAR(100))
    *   `last_name` (VARCHAR(100))
    *   `created_at` (DATETIME - NOT NULL, DEFAULT CURRENT_TIMESTAMP)
    *   `updated_at` (DATETIME - DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP)
    *   `last_active_plan_id` (VARCHAR(36) - Foreign Key to `training_plans.id`, NULLABLE)

2.  **`training_plans` Table:**
    *   `id` (VARCHAR(36) - UUID, Primary Key)
    *   `user_id` (VARCHAR(36) - Foreign Key to `users.id`, NOT NULL)
    *   `name` (VARCHAR(255) - NOT NULL)
    *   `description` (TEXT)
    *   `is_active` (BOOLEAN - NOT NULL, DEFAULT FALSE)
    *   `created_at` (DATETIME - NOT NULL, DEFAULT CURRENT_TIMESTAMP)
    *   `updated_at` (DATETIME - DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP)

3.  **`exercises` Table (Master Exercise List & Plan-Specific Exercise Details):**
    *   `id` (VARCHAR(36) - UUID, Primary Key)
    *   `plan_id` (VARCHAR(36) - Foreign Key to `training_plans.id`, NOT NULL)
    *   `name` (VARCHAR(255) - NOT NULL)
    *   `muscle_group` (VARCHAR(100))
    *   `notes` (TEXT)
    *   `target_sets` (INT - NOT NULL)
    *   `target_reps_min` (INT - NOT NULL)
    *   `target_reps_max` (INT - NOT NULL)
    *   `recommended_rest_seconds` (INT - NOT NULL)
    *   `sequence_order` (INT - Order within a workout day, NOT NULL)
    *   `day_of_week` (VARCHAR(255) - Comma-separated days, e.g., "MONDAY,WEDNESDAY,FRIDAY", NULLABLE)
    *   `workout_day_sequence` (INT - For "Day 1", "Day 2" plans, NULLABLE)
    *   `recommended_weight_start` (DOUBLE - NULLABLE)
    *   `unit` (VARCHAR(10) - 'KG' or 'LBS', NOT NULL, DEFAULT 'KG')

4.  **`workout_sessions` Table:**
    *   `id` (VARCHAR(36) - UUID, Primary Key)
    *   `user_id` (VARCHAR(36) - Foreign Key to `users.id`, NOT NULL)
    *   `plan_id` (VARCHAR(36) - Foreign Key to `training_plans.id`, NOT NULL)
    *   `start_time` (DATETIME - NOT NULL)
    *   `end_time` (DATETIME - NULLABLE)
    *   `duration_seconds` (INT - NULLABLE)
    *   `created_at` (DATETIME - NOT NULL, DEFAULT CURRENT_TIMESTAMP)

5.  **`exercise_logs` Table:**
    *   `id` (VARCHAR(36) - UUID, Primary Key)
    *   `session_id` (VARCHAR(36) - Foreign Key to `workout_sessions.id`, NOT NULL)
    *   `exercise_id` (VARCHAR(36) - Foreign Key to `exercises.id`, NOT NULL)
    *   `exercise_name` (VARCHAR(255) - Denormalized for easier querying, NOT NULL)
    *   `set_number` (INT - NOT NULL)
    *   `reps` (INT - NOT NULL)
    *   `weight` (DOUBLE - NOT NULL)
    *   `unit` (VARCHAR(10) - 'KG' or 'LBS', NOT NULL, DEFAULT 'KG')
    *   `rpe` (INT - NULLABLE, 1-10)
    *   `notes` (TEXT)
    *   `logged_at` (DATETIME - NOT NULL, DEFAULT CURRENT_TIMESTAMP)

6.  **`body_metrics` Table:**
    *   `id` (VARCHAR(36) - UUID, Primary Key)
    *   `user_id` (VARCHAR(36) - Foreign Key to `users.id`, NOT NULL)
    *   `logged_at` (DATETIME - NOT NULL, DEFAULT CURRENT_TIMESTAMP)
    *   `weight_kg` (DOUBLE - NULLABLE)
    *   `body_fat_percentage` (DOUBLE - NULLABLE)
    *   `bmi` (DOUBLE - NULLABLE)
    *   `bicep_cm` (DOUBLE - NULLABLE)
    *   `waist_cm` (DOUBLE - NULLABLE)
    *   `notes` (TEXT)

---

### **Prompt 2: User Authentication Backend (Spring Boot)**

**Objective:** Implement secure user registration, login, and token refresh using Spring Security and JWT.

**Instructions for the AI Model:**

1.  **`User` Entity:**
    *   Map to the `users` table.
    *   Implement `UserDetails` interface.
    *   Add `@Column` annotations for all fields including `@GeneratedValue(generator = "uuid2")` for ID and `@GenericGenerator(name = "uuid2", strategy = "uuid2")`.

2.  **Registration API:**
    *   **Endpoint:** `POST /api/auth/register`
    *   **Request:** `RegisterRequest` DTO (email, password, firstName, lastName).
    *   **Logic:**
        *   Validate request.
        *   Check if email already exists.
        *   Hash password using `BCryptPasswordEncoder`.
        *   Save new `User` to database.
        *   Return `AuthResponse` DTO (JWT token, user details) upon successful registration and immediate login.

3.  **Login API:**
    *   **Endpoint:** `POST /api/auth/login`
    *   **Request:** `LoginRequest` DTO (email, password).
    *   **Logic:**
        *   Authenticate user credentials using `AuthenticationManager`.
        *   Generate JWT token upon successful authentication.
        *   Return `AuthResponse` DTO (JWT token, user details).

4.  **JWT Token Generation & Validation:**
    *   Create a `JwtService` to:
        *   Generate token (using `jjwt` library) with `userId` and `email` as claims.
        *   Extract claims from token.
        *   Validate token.
    *   Define `JwtAuthenticationFilter` to intercept requests, extract and validate tokens, and set `SecurityContext`.

5.  **Spring Security Configuration:**
    *   Configure `HttpSecurity` to:
        *   Permit `/api/auth/**` endpoints.
        *   Require authentication for all other `/api/**` endpoints.
        *   Add JWT filter before `UsernamePasswordAuthenticationFilter`.
        *   Disable CSRF.
        *   Configure session management to stateless.
        *   Define `AuthenticationProvider` and `AuthenticationManagerBean`.

6.  **Custom `UserDetailsService`:**
    *   Implement to load user by email for Spring Security.

---

### **Prompt 3: Training Plan Management Backend (Spring Boot)**

**Objective:** Implement CRUD operations for training plans and the ability to set a plan as active.

**Instructions for the AI Model:**

1.  **`TrainingPlan` Entity:** Map to the `training_plans` table. Define relationships (`@OneToMany` with `Exercise`).
2.  **`Exercise` Entity:** Map to the `exercises` table. Define relationship (`@ManyToOne` with `TrainingPlan`).
3.  **TrainingPlan DTOs:**
    *   `TrainingPlanRequest` (for creating/updating plans, including `List<ExerciseDto>`).
    *   `TrainingPlanResponse` (for returning plan details, including `List<ExerciseDto>`).
    *   `ExerciseDto` (for exercise details within a plan).

4.  **`TrainingPlanController`:**
    *   **`POST /api/plans`:** Create a new training plan (manual creation or after parsing).
        *   Request body: `TrainingPlanRequest`.
        *   Assign `user_id` from authenticated user.
        *   Generate UUIDs for plan and exercises.
        *   Save plan and associated exercises.
        *   Return `TrainingPlanResponse`.
    *   **`GET /api/plans`:** Get all training plans for the authenticated user.
        *   Return `List<TrainingPlanResponse>`.
    *   **`GET /api/plans/{planId}`:** Get a specific training plan by ID.
        *   Return `TrainingPlanResponse`.
        *   Ensure plan belongs to the authenticated user.
    *   **`PUT /api/plans/{planId}`:** Update an existing training plan.
        *   Request body: `TrainingPlanRequest`.
        *   Ensure plan belongs to the authenticated user.
        *   Handle updates to existing exercises, deletion of removed exercises, and addition of new ones.
        *   Return `TrainingPlanResponse`.
    *   **`DELETE /api/plans/{planId}`:** Delete a training plan.
        *   Ensure plan belongs to the authenticated user.
    *   **`PUT /api/plans/{planId}/set-active`:** Set a training plan as the active plan for the user.
        *   Logic: Deactivate all other plans for the user, then activate the specified plan.
        *   Update `users.last_active_plan_id`.
        *   Return `TrainingPlanResponse` for the activated plan.

5.  **Service & Repository Layers:**
    *   `TrainingPlanService`: Contains business logic for plan management.
    *   `TrainingPlanRepository`, `ExerciseRepository`: Spring Data JPA repositories.

---

### **Prompt 4: File Upload & Parsing Backend (Spring Boot + AI Integration)**

**Objective:** Implement file upload endpoint, orchestrate text extraction, chunking, and integration with an external (or internal rule-based) parsing mechanism to transform file content into the `TrainingPlan` JSON structure.

**Instructions for the AI Model:**

1.  **Dependencies (Add to `pom.xml`):**
    *   `apache.poi:poi-ooxml` (for .docx)
    *   `org.apache.pdfbox:pdfbox` (for .pdf)
    *   `net.sourceforge.tess4j:tess4j` (for Tesseract OCR Java wrapper)

2.  **`FileParsingController`:**
    *   **`POST /api/plans/upload`:** Endpoint for file upload.
        *   **Request:** `MultipartFile` for the uploaded file.
        *   **Logic:**
            *   Receive the `MultipartFile`.
            *   Determine file type (Word, PDF, Image).
            *   Call `FileProcessorService` to handle extraction and parsing.
            *   Upon successful parsing, save the returned `TrainingPlanRequest` (from parsed JSON) to the database using `TrainingPlanService`.
            *   Return `TrainingPlanResponse` of the newly created plan.
            *   Handle `IOException`, `ParsingException`, `UnsupportedFileTypeException`.

3.  **`FileProcessorService`:**
    *   This service orchestrates the file processing pipeline.
    *   **`processFile(MultipartFile file)` method:**
        *   **Text Extraction:**
            *   If `.docx`: Use `XWPFDocument` from Apache POI to extract text, paragraph by paragraph.
            *   If `.pdf`: Use `PDDocument` and `PDFTextStripper` from Apache PDFBox to extract text page by page.
            *   If Image:
                *   Use `ImageIO` to read the image.
                *   Perform optional image pre-processing (grayscale, binarization) using `BufferedImage` manipulation.
                *   Use `Tess4j.doOCR()` to perform OCR and get raw text.
        *   **Text Chunking:**
            *   If the extracted text (or the number of pages/paragraphs) is large, split it into smaller `String` chunks.
            *   **Heuristic:** Aim for chunks around 1000-2000 characters for LLMs, or logical blocks for rule-based. Ensure chunks don't cut in the middle of a potential exercise description.
        *   **Iterative Parsing (Core Logic):**
            *   Loop through each text chunk.
            *   Call an internal `ParsingService` (or external LLM API) for each chunk.
            *   **`ParsingService` (Internal Rule-Based Example):**
                *   **Method:** `parseChunkForExercises(String chunkText)`
                *   Use Java Regex patterns (e.g., `Pattern` and `Matcher`) to identify exercise names, sets (e.g., "3x8", "3 sets of 8 reps"), reps ranges ("8-12 reps"), rest times ("90s rest", "2 min rest"), and notes.
                *   Build a `List<ExerciseDto>` from each chunk.
                *   *This will be the most complex part to implement purely with rules.*
            *   **`LlmParsingService` (External LLM Example):**
                *   **Method:** `sendToLlmForParsing(String chunkText)`
                *   Construct the LLM prompt as described in the "Large File Strategy" section.
                *   Make an HTTP POST request to the chosen LLM API (e.g., Gemini Pro, GPT-3.5).
                *   Parse the LLM's JSON response into `List<ExerciseDto>`.
        *   **Aggregation & Consolidation:**
            *   Collect all `List<ExerciseDto>` from each chunk.
            *   Combine into a single `List<ExerciseDto>`.
            *   Implement logic to identify and merge duplicate exercises (e.g., if "Barbell Squats" is identified on two different pages, merge its details, or keep the most complete one).
            *   Infer `planName` and `description` from an initial chunk or prompt the user if needed.
            *   Construct and return a `TrainingPlanRequest` object.

5.  **Exception Handling:**
    *   `UnsupportedFileTypeException`.
    *   `ParsingException` (e.g., if rules fail, or LLM returns invalid JSON).

---

### **Prompt 5: Daily Workout & Exercise Tracking Backend (Spring Boot)**

**Objective:** Provide endpoints for getting today's workout, starting/ending workout sessions, and logging individual exercise sets.

**Instructions for the AI Model:**

1.  **Entities:** `WorkoutSession`, `ExerciseLog`.
2.  **DTOs:**
    *   `WorkoutSessionResponse` (full details including `List<ExerciseLogDto>`).
    *   `ExerciseLogRequest` (for logging a single set).
    *   `ExerciseLogResponse`.
    *   `TodaysWorkoutResponse` (contains `planName`, `date`, `List<TodaysExerciseDto>`).
    *   `TodaysExerciseDto` (exercise details + `lastPerformance`).
    *   `LastPerformanceDto` (reps, weight, set count from last time).

3.  **`WorkoutController`:**
    *   **`GET /api/workouts/today`:** Get the exercises scheduled for today based on the active plan.
        *   **Logic:**
            *   Retrieve the user's `last_active_plan_id` from the `users` table.
            *   If no active plan, return appropriate message.
            *   Retrieve `Exercises` for that plan, ordered by `sequence_order`.
            *   For each exercise, query `exercise_logs` to find the `lastPerformance` for that specific exercise by the user (most recent `logged_at` date for that `exercise_id`). Aggregate reps, weight.
            *   Return `TodaysWorkoutResponse`.
    *   **`POST /api/workouts/sessions/start`:** Start a new workout session.
        *   **Request:** Simple DTO containing `planId` (optional, if user wants to override active plan).
        *   **Logic:**
            *   Create a new `WorkoutSession` record with `startTime`.
            *   Return `WorkoutSessionResponse` (with generated ID).
    *   **`POST /api/workouts/sessions/{sessionId}/log`:** Log a single set for an exercise within an active session.
        *   **Request:** `ExerciseLogRequest` (exerciseId, setNumber, reps, weight, rpe, notes).
        *   **Logic:**
            *   Validate `sessionId` and `exerciseId` belong to the user and active plan.
            *   Create and save a new `ExerciseLog` record.
            *   Return `ExerciseLogResponse`.
    *   **`PUT /api/workouts/sessions/{sessionId}/end`:** End a workout session.
        *   **Logic:**
            *   Update `WorkoutSession` with `endTime` and calculate `duration_seconds`.
            *   Return `WorkoutSessionResponse`.
    *   **`GET /api/workouts/exercises/{exerciseId}/last-performance`:** Get the last recorded performance for a specific exercise for the authenticated user.
        *   Return `LastPerformanceDto`.

4.  **Service & Repository Layers:**
    *   `WorkoutService`, `ExerciseLogService`.
    *   `WorkoutSessionRepository`, `ExerciseLogRepository`.

---

### **Prompt 6: Progress Tracking Backend (Spring Boot)**

**Objective:** Implement endpoints to query and aggregate historical data for progress visualization (graphs).

**Instructions for the AI Model:**

1.  **DTOs:**
    *   `ProgressDataPointDto` (date, value for weight, reps, or volume).
    *   `ExerciseProgressResponse` (list of `ProgressDataPointDto`).

2.  **`ProgressController`:**
    *   **`GET /api/progress/exercise/{exerciseId}`:** Get progress data for a specific exercise.
        *   **Path Variable:** `exerciseId`.
        *   **Query Params:** `metric` (e.g., "WEIGHT", "REPS", "VOLUME"), `timeframe` (e.g., "30D", "3M", "6M", "ALL").
        *   **Logic:**
            *   Query `exercise_logs` for the specified `exerciseId` and `user_id`.
            *   Filter by `logged_at` based on `timeframe`.
            *   **Aggregation:**
                *   **WEIGHT:** Group by date (or week/month for longer timeframes) and get the maximum `weight` lifted in that period.
                *   **REPS:** Group by date and sum `reps` (or average reps per set).
                *   **VOLUME:** Group by date and sum (`weight` * `reps`) for each set.
            *   Return `ExerciseProgressResponse` (`List<ProgressDataPointDto>`).
    *   **`GET /api/progress/overall` (Optional - for high-level stats):** Get overall progress (e.g., total workouts, total volume across all exercises).
        *   **Query Params:** `timeframe`.
        *   Return appropriate DTO (e.g., `OverallProgressDto` with total workouts, total volume, etc.).

3.  **Service & Repository Layers:**
    *   `ProgressService` (contains complex aggregation logic).
    *   `ExerciseLogRepository` (use custom queries with `@Query` annotations for aggregation).

---

### **Prompt 7: History & Profile Backend (Spring Boot)**

**Objective:** Implement endpoints to retrieve workout history, individual workout session details, and manage user profile and body metrics.

**Instructions for the AI Model:**

1.  **DTOs:**
    *   `WorkoutHistoryItemDto` (sessionId, date, planName, duration, totalExercises).
    *   `WorkoutSessionDetailResponse` (full session details, `List<ExerciseLogResponse>`).
    *   `UserProfileResponse` (user details, last active plan info).
    *   `UpdateUserProfileRequest` (for changing name, email, password).
    *   `BodyMetricRequest` (date, weight, bodyFat, etc.).
    *   `BodyMetricResponse`.
    *   `BodyMetricHistoryResponse` (list of `BodyMetricResponse`).

2.  **`HistoryController`:**
    *   **`GET /api/history/sessions`:** Get all workout sessions for the authenticated user.
        *   **Query Params:** `planId` (optional filter), `sortBy` (date_asc/date_desc).
        *   Return `List<WorkoutHistoryItemDto>`.
    *   **`GET /api/history/sessions/{sessionId}`:** Get details of a specific workout session.
        *   Return `WorkoutSessionDetailResponse`.
        *   Ensure session belongs to the authenticated user.

3.  **`ProfileController`:**
    *   **`GET /api/profile`:** Get authenticated user's profile information.
        *   Return `UserProfileResponse`.
    *   **`PUT /api/profile`:** Update authenticated user's profile.
        *   **Request:** `UpdateUserProfileRequest`.
        *   Handle password change (re-hash password if provided).
        *   Return `UserProfileResponse`.
    *   **`POST /api/profile/body-metrics`:** Log new body metrics.
        *   **Request:** `BodyMetricRequest`.
        *   Return `BodyMetricResponse`.
    *   **`GET /api/profile/body-metrics`:** Get body metric history for the authenticated user.
        *   **Query Params:** `timeframe` (optional).
        *   Return `BodyMetricHistoryResponse`.
    *   **`GET /api/profile/body-metrics/weight-progress`:** Get specific graph data for body weight.
        *   **Query Params:** `timeframe`.
        *   Return `List<ProgressDataPointDto>`.

4.  **Service & Repository Layers:**
    *   `UserService`, `BodyMetricService`.
    *   `BodyMetricRepository`.

---

### **Prompt 8: Cross-Cutting Concerns & Backend Polish (Spring Boot)**

**Objective:** Ensure robustness, maintainability, and security across the backend.

**Instructions for the AI Model:**

1.  **Global Exception Handling:**
    *   Implement `@ControllerAdvice` and `@ExceptionHandler` to provide consistent error responses (e.g., `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `500 Internal Server Error`).
    *   Define custom exception classes (e.g., `ResourceNotFoundException`, `UnauthorizedException`, `DuplicateEmailException`).

2.  **Input Validation:**
    *   Use `@Valid` annotation on DTOs in controllers.
    *   Define validation rules using `@NotNull`, `@Size`, `@Email`, etc., on DTO fields.
    *   Implement custom validators if needed.

3.  **Logging:**
    *   Integrate `SLF4J` with `Logback` (Spring Boot default).
    *   Add appropriate logging statements (INFO, DEBUG, ERROR) in services and controllers for request handling, data persistence, and error conditions.

4.  **Security Best Practices:**
    *   Ensure password hashing is correctly implemented with `BCryptPasswordEncoder`.
    *   Properly secure all endpoints with JWT, ensuring only authenticated users can access protected resources.
    *   Implement role-based authorization if different user roles are ever considered (e.g., admin vs. regular user), though not explicitly requested yet.
    *   Sanitize all user inputs to prevent SQL injection or other attacks.

5.  **Code Structure & Readability:**
    *   Organize code into standard Spring Boot packages (`.controller`, `.service`, `.repository`, `.model`, `.dto`, `.config`, `.exception`, `.security`).
    *   Ensure clear separation of concerns between layers.
    *   Write clean, self-documenting code with meaningful variable and method names.
    *   Add Javadoc comments for public methods and complex logic.

6.  **Configuration:**
    *   Use `application.properties` or `application.yml` for database connection, JWT secret, server port, etc.
    *   Implement environment-specific configurations (e.g., `application-dev.yml`, `application-prod.yml`).

7.  **Swagger/OpenAPI (Optional but Recommended):**
    *   Integrate `springdoc-openapi-ui` to generate API documentation automatically. This helps frontend developers understand and integrate with the backend API.

---